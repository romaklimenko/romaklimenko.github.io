{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2016/a-first-look-at-category-theory/","result":{"data":{"site":{"siteMetadata":{"title":"Roman Klimenko"}},"markdownRemark":{"id":"dd4b6232-cc63-5955-a173-f8b213c6e2cb","excerpt":"Motivation While many of functional programming concepts are derived from category theory, we often hear that it’s not necessary to learn it if we want to…","html":"<h2>Motivation</h2>\n<p>While many of functional programming concepts are derived from <a href=\"https://en.wikipedia.org/wiki/Category_theory\">category theory</a>, we often hear that it’s not necessary to learn it if we want to understand its concepts. This is, of course, is not true.</p>\n<p>*<em>But here's an article with a partially opposite opinion: <a href=\"https://jozefg.bitbucket.io/posts/2013-10-14-please-dont-learn-cat-theory.html\">https://jozefg.bitbucket.io/posts/2013-10-14-please-dont-learn-cat-theory.html</a></em></p>\n<p>If <a href=\"https://www.haskell.org/\">Haskell</a> is not a language of our choice, we are forced to map Haskell patterns to our language while these patterns are mapped to Haskell from category theory. A lot of important information is lost in translation.</p>\n<p>This is why we start not from programming but from the theory itself. We will see that the theory is not only about programming but we will get back to some code samples at the end of the article.</p>\n<blockquote>\n<p>When we formalize our ideas, our understanding is almost always clarified.<br>\n– David I. Spivak in Category Theory for Scientists</p>\n</blockquote>\n<p>In fact, category theory is not so hard to grasp like we may think about. Some even think they can teach <a href=\"https://arxiv.org/pdf/quant-ph/0510032.pdf\">Quantum Mechanics in kindergarten</a> with it. The theory is intended to make things simpler, by using the right “language” and formalism.</p>\n<p>Things are getting more complicated if we map the theory implementation to the theory instead of mapping the theory to things we implement.</p>\n<p>The purpose of this article is to write down very basic concepts of category Theory and <em>only then</em> get back to examples in the programming world.</p>\n<h2>Category Theory 101</h2>\n<blockquote>\n<p>Category Theory formalizes mathematical structure and its concepts in terms of a collection of objects and of arrows (also called morphisms).<br>\n– Wikipedia</p>\n</blockquote>\n<p>Category theory is an area of mathematics that studies the properties of relationships between mathematical objects, <em>which do not depend on the internal structure</em> of these objects.</p>\n<h2>Objects and Morphisms</h2>\n<p>Let’s take an <code class=\"language-text\">A</code> and <code class=\"language-text\">B</code>. These are two objects, mathematical structures, types — whatever. No matter how do we call it because we don’t care about theirs internal structure.</p>\n<p>Now let’s draw a line between <code class=\"language-text\">A</code> and <code class=\"language-text\">B</code> and name it <code class=\"language-text\">f</code>:</p>\n<img src=\"morphism.png\" class=\"img-fluid\" />\n<p>This line is called <a href=\"https://en.wikipedia.org/wiki/Morphism\">morphism</a>. While morphism <a href=\"http://mathoverflow.net/questions/119913/what-is-the-difference-between-a-function-and-a-morphism\">isn’t necessary a function</a>, in category theory, it usually means a function.</p>\n<p>If we think about the morphism as about a function from A to B, we can also think about A and B as about types or sets:</p>\n<div class=\"gatsby-highlight\" data-language=\"none\"><pre class=\"language-none\"><code class=\"language-none\">f : A → B</code></pre></div>\n<h2>Composition</h2>\n<p>Now take another object, let’s call it <code class=\"language-text\">C</code> and let’s draw a <code class=\"language-text\">g : B → C</code>:</p>\n<img src=\"abc.png\" class=\"img-fluid\" />\n<p>We can easily see that if we follow the arrows <code class=\"language-text\">f</code> and <code class=\"language-text\">g</code> we can get from <code class=\"language-text\">A</code> to <code class=\"language-text\">C</code> via <code class=\"language-text\">B</code>, because the end of <code class=\"language-text\">f</code> is the same as the beginning of <code class=\"language-text\">g</code>. Beginning of every morphism is called a <em>domain</em> (<code class=\"language-text\">dom</code>) and ending is a <em>codomain</em> (<code class=\"language-text\">cod</code>). So we can say that:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">A = dom(f), B = cod(f)</code></pre></div>\n<p>and for <code class=\"language-text\">f : A → B</code> and <code class=\"language-text\">g : B → C</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cod(f) = dom(g)</code></pre></div>\n<p>Joining two morphisms that match with their domain and codomain is called <em>composition</em> and denoted as:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">g ∘ f</code></pre></div>\n<p>which produces a new morphism (function). So that:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">∀ a ∈ A, (g ∘ f)(a) = g(f(a))</code></pre></div>\n<p>which means: for every <code class=\"language-text\">a</code> in <code class=\"language-text\">A</code>, a composition of <code class=\"language-text\">g</code> after <code class=\"language-text\">f</code> applied to <code class=\"language-text\">a</code> is the same as the result of <code class=\"language-text\">g(f(a))</code>.</p>\n<img src=\"composition.png\" class=\"img-fluid\" />\n<p>In this way, we can connect as many objects as we need. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">h : C → D</code></pre></div>\n<img src=\"composition2.png\" class=\"img-fluid\" />\n<h2>Associativity</h2>\n<p>Operator <code class=\"language-text\">∘</code> is <a href=\"https://en.wikipedia.org/wiki/Operator_associativity\">associative</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(h ∘ g) ∘ f = h ∘ (g ∘ f)\n∵ ∀ a ∈ A, ((h ∘ g) ∘ f)(a) = h(g(f(a)))=(h ∘ (g ∘ f))(a)</code></pre></div>\n<h2>Identity</h2>\n<p>Every object we introduced has an <a href=\"https://ncatlab.org/nlab/show/identity+morphism\">Identity</a> morphism:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1A : A → A\n∀ a ∈ A, 1A(a) = a</code></pre></div>\n<p>Identities are composable as usuall morphisms:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">f ∘ 1A = f = 1B ∘ f</code></pre></div>\n<h2>Category</h2>\n<p>Now we have everything to define a <a href=\"https://en.wikipedia.org/wiki/Category_%28mathematics%29\">category</a>.</p>\n<p>A category consists of following:</p>\n<ul>\n<li>Objects: <code class=\"language-text\">A</code>, <code class=\"language-text\">B</code>, <code class=\"language-text\">C</code>, …</li>\n<li>Morphisms: <code class=\"language-text\">f</code>, <code class=\"language-text\">g</code>, …</li>\n<li>Identities for every object: <code class=\"language-text\">1A</code>, <code class=\"language-text\">1B</code>, <code class=\"language-text\">1C</code>, …</li>\n</ul>\n<p>The following laws must be satisfied:</p>\n<ul>\n<li>Associativity:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(∀ f : A → B, g : B → C, h : C → D), h ∘ (g ∘ f) = (h ∘ g) ∘ f</code></pre></div>\n<p>Which means: for all the functions that are composable with each other composition is associative.</p>\n<ul>\n<li>Unit:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(∀ f : A → B), f ∘ 1A = f = 1B ∘ f</code></pre></div>\n<p>Which means: every function <code class=\"language-text\">f : A → B</code> is equal to <code class=\"language-text\">f ∘ 1A</code> and is equal to <code class=\"language-text\">1B ∘ f</code>.</p>\n<p>So generally speaking, <em>a category is a set of objects connected with arrows and limited by associativity and unit laws</em>.</p>\n<p>Of course, there is a lot more interesting in category theory, but these basics are enough to start thinking about more complex concepts. All these monoids, functors, monads etc. are just about connecting objects with arrows and this is <em>not</em> only about programming.</p>\n<h2>Get into the code</h2>\n<p>It’s natural to map these concepts to any of modern programming languages.</p>\n<h3>Haskell</h3>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Integral</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">mod</span> <span class=\"token hvariable\">a</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span>\n\n<span class=\"token hvariable\">g</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Bool</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Char</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">g</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token hvariable\">b</span> <span class=\"token keyword\">then</span> <span class=\"token string\">\"True\"</span> <span class=\"token keyword\">else</span> <span class=\"token string\">\"False\"</span>\n\n<span class=\"token hvariable\">composed</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Integral</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Char</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">composed</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">g</span><span class=\"token operator\"> . </span><span class=\"token hvariable\">f</span>\n\n<span class=\"token hvariable\">composed</span> <span class=\"token number\">2</span> <span class=\"token comment\">-- True</span>\n<span class=\"token hvariable\">composed</span> <span class=\"token number\">3</span> <span class=\"token comment\">-- False</span></code></pre></div>\n<h3>JavaScript:</h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">compose</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">g<span class=\"token punctuation\">,</span> f</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token parameter\">a</span> <span class=\"token operator\">=></span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">f</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">a</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">g</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">b</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">?</span> <span class=\"token string\">\"True\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"False\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> composed <span class=\"token operator\">=</span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">)</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">assert</span><span class=\"token punctuation\">(</span><span class=\"token function\">composed</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">\"True\"</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">assert</span><span class=\"token punctuation\">(</span><span class=\"token function\">composed</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">\"False\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3>C#:</h3>\n<div class=\"gatsby-highlight\" data-language=\"cs\"><pre class=\"language-cs\"><code class=\"language-cs\"><span class=\"token keyword\">using</span> <span class=\"token namespace\">System</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> <span class=\"token namespace\">Xunit</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">namespace</span> <span class=\"token namespace\">Category</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CategoryExtensions</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token return-type class-name\">Func<span class=\"token punctuation\">&lt;</span>A<span class=\"token punctuation\">,</span> C<span class=\"token punctuation\">></span></span> <span class=\"token generic-method\"><span class=\"token function\">Compose</span><span class=\"token generic class-name\"><span class=\"token punctuation\">&lt;</span>A<span class=\"token punctuation\">,</span> B<span class=\"token punctuation\">,</span> C<span class=\"token punctuation\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token class-name\">Func<span class=\"token punctuation\">&lt;</span>B<span class=\"token punctuation\">,</span> C<span class=\"token punctuation\">></span></span> g<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Func<span class=\"token punctuation\">&lt;</span>A<span class=\"token punctuation\">,</span> B<span class=\"token punctuation\">></span></span> f<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> x <span class=\"token operator\">=></span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CategoryTest</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Func<span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span><span class=\"token punctuation\">></span></span> f <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">int</span></span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> i <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">Func<span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">string</span><span class=\"token punctuation\">></span></span> g <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">bool</span></span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> b <span class=\"token punctuation\">?</span> <span class=\"token string\">\"True\"</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">\"False\"</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token punctuation\">[</span><span class=\"token attribute\"><span class=\"token class-name\">Theory</span></span><span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">[</span><span class=\"token attribute\"><span class=\"token class-name\">InlineData</span><span class=\"token attribute-arguments\"><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"True\"</span><span class=\"token punctuation\">)</span></span></span><span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">[</span><span class=\"token attribute\"><span class=\"token class-name\">InlineData</span><span class=\"token attribute-arguments\"><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"False\"</span><span class=\"token punctuation\">)</span></span></span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Composition</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">int</span></span> input<span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token keyword\">string</span></span> output<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// Act</span>\n            <span class=\"token class-name\">Func<span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">string</span><span class=\"token punctuation\">></span></span> composed <span class=\"token operator\">=</span> g<span class=\"token punctuation\">.</span><span class=\"token function\">Compose</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// Assert</span>\n            Assert<span class=\"token punctuation\">.</span><span class=\"token function\">Equal</span><span class=\"token punctuation\">(</span><span class=\"token function\">composed</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> output<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>F#:</h3>\n<div class=\"gatsby-highlight\" data-language=\"fsharp\"><pre class=\"language-fsharp\"><code class=\"language-fsharp\"><span class=\"token comment\">// val f : (int -> bool)</span>\n<span class=\"token keyword\">let</span> f a <span class=\"token operator\">=</span> a <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n<span class=\"token comment\">// val g : (bool -> string)</span>\n<span class=\"token keyword\">let</span> g b <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> b <span class=\"token keyword\">then</span> <span class=\"token string\">\"True\"</span> <span class=\"token keyword\">else</span> <span class=\"token string\">\"False\"</span>\n\n<span class=\"token comment\">// val composed : (int -> string)</span>\n<span class=\"token keyword\">let</span> composed <span class=\"token operator\">=</span> g <span class=\"token operator\">&lt;&lt;</span> f\n\n<span class=\"token operator\">></span> <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> composed <span class=\"token number\">2</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// val e : string = \"True\"</span>\n\n<span class=\"token operator\">></span> <span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> composed <span class=\"token number\">2</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// val y : string = \"False\"</span></code></pre></div>","fields":{"slug":"/blog/2016/a-first-look-at-category-theory/"},"frontmatter":{"title":"A first look at category theory","date":"October 21, 2016","tags":["category-theory"],"description":null}},"previous":{"fields":{"slug":"/blog/2016/drawing/"},"frontmatter":{"title":"People draw my photos!"}},"next":{"fields":{"slug":"/blog/2016/sitecore-in-docker/"},"frontmatter":{"title":"Running Sitecore in Docker"}}},"pageContext":{"id":"dd4b6232-cc63-5955-a173-f8b213c6e2cb","previousPostId":"24475fd0-d1ec-598f-aa81-a76b8b394f31","nextPostId":"f99f5a3b-5594-562f-86f4-5ccc5c6a722d"}},"staticQueryHashes":["2841359383"]}