{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2016/sql/","result":{"data":{"site":{"siteMetadata":{"title":"Roman Klimenko"}},"markdownRemark":{"id":"0e4f4a7b-ed27-54ab-8a74-62bea4cae571","excerpt":"This is just a small observation about one counterintuitive feature of the SQL language.\nSQL (Structured Query Language) was initially named SEQUEL (Structured…","html":"<p>This is just a small observation about one counterintuitive feature of the SQL language.\nSQL (Structured Query Language) was initially named <a href=\"https://en.wikipedia.org/wiki/SQL#History\">SEQUEL</a> (Structured <em>English</em> Query Language). One word clearly explains why the “keyed-in” SQL statements order is different than the logical query processing order.</p>\n<p>Say, we’d like to ask someone for a bottle of beer from a fridge. The first thing we think about is <em>what</em> do we want (a beer) and only then <em>how</em> to get it (from the fridge).</p>\n<p>In English, we’d say:</p>\n<blockquote>\n<p>Give me a bottle of beer from the fridge, please.</p>\n</blockquote>\n<p>First, <em>what</em> do we want, second, <em>how</em> to get it.</p>\n<p>But if we wrote a program, we want to make an algorithm: first — <em>how</em>, second — <em>what</em>:</p>\n<blockquote>\n<p>Open the fridge, take a bottle of beer.</p>\n</blockquote>\n<p>The so-called “<a href=\"https://msdn.microsoft.com/en-us/library/ms189499.aspx#Anchor_2\">keyed-in order</a>” of a standard SQL query is:</p>\n<ol>\n<li><code class=\"language-text\">SELECT</code></li>\n<li><code class=\"language-text\">FROM</code></li>\n<li><code class=\"language-text\">WHERE</code></li>\n<li><code class=\"language-text\">GROUP BY</code></li>\n<li><code class=\"language-text\">HAVING</code></li>\n<li><code class=\"language-text\">ORDER BY</code></li>\n</ol>\n<p>But the logical query processing order is different:</p>\n<ol>\n<li><code class=\"language-text\">FROM</code></li>\n<li><code class=\"language-text\">WHERE</code></li>\n<li><code class=\"language-text\">GROUP BY</code></li>\n<li><code class=\"language-text\">HAVING</code></li>\n<li><code class=\"language-text\">SELECT</code></li>\n<li><code class=\"language-text\">ORDER BY</code></li>\n</ol>\n<p>This is why we can’t, for example, refer in the <code class=\"language-text\">WHERE</code> clause to a column alias defined in the <code class=\"language-text\">SELECT</code> clause. This isn't allowed because the <code class=\"language-text\">WHERE</code> clause is evaluated before the <code class=\"language-text\">SELECT</code> clause.</p>\n<p>Now take a classic SQL query:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> Country<span class=\"token punctuation\">,</span> <span class=\"token keyword\">YEAR</span><span class=\"token punctuation\">(</span>HireDate<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> YearHired<span class=\"token punctuation\">,</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> NumEmployees\n<span class=\"token keyword\">FROM</span> Employees\n<span class=\"token keyword\">WHERE</span> HireDate <span class=\"token operator\">>=</span> <span class=\"token string\">'19920101'</span>\n<span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span> Country<span class=\"token punctuation\">,</span> <span class=\"token keyword\">YEAR</span><span class=\"token punctuation\">(</span>HireDate<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">HAVING</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> Country<span class=\"token punctuation\">,</span> YearHired <span class=\"token keyword\">DESC</span></code></pre></div>\n<p>And compare to it’s LINQ-expression equivalent:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token class-name\"><span class=\"token keyword\">var</span></span> result <span class=\"token operator\">=</span>  <span class=\"token keyword\">from</span> e <span class=\"token keyword\">in</span> Employees\n              <span class=\"token keyword\">where</span> <span class=\"token class-name\">e</span><span class=\"token punctuation\">.</span>HireDate <span class=\"token operator\">>=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">DateTime</span><span class=\"token punctuation\">(</span><span class=\"token number\">1992</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n              <span class=\"token keyword\">group</span> e <span class=\"token keyword\">by</span> e<span class=\"token punctuation\">.</span>Country <span class=\"token keyword\">into</span> g\n              <span class=\"token keyword\">where</span> <span class=\"token class-name\">g</span><span class=\"token punctuation\">.</span><span class=\"token function\">Count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">1</span>\n              <span class=\"token keyword\">orderby</span> g<span class=\"token punctuation\">.</span>Key <span class=\"token keyword\">descending</span>\n              <span class=\"token keyword\">select</span> <span class=\"token keyword\">new</span> <span class=\"token punctuation\">{</span> g<span class=\"token punctuation\">.</span>Key<span class=\"token punctuation\">,</span> Count <span class=\"token operator\">=</span> g<span class=\"token punctuation\">.</span><span class=\"token function\">Count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The <code class=\"language-text\">select</code> at the last line looks more natural, isn't it?</p>\n<p>Of course, <code class=\"language-text\">orderby</code> goes before the <code class=\"language-text\">select</code>, but this is exactly how it is processed in the LINQ code:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token class-name\"><span class=\"token keyword\">var</span></span> result2 <span class=\"token operator\">=</span> Employees\n    <span class=\"token punctuation\">.</span><span class=\"token function\">Where</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=></span> e<span class=\"token punctuation\">.</span>HireDate <span class=\"token operator\">>=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">DateTime</span><span class=\"token punctuation\">(</span><span class=\"token number\">1992</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">GroupBy</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=></span> e<span class=\"token punctuation\">.</span>Country<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">Where</span><span class=\"token punctuation\">(</span>g <span class=\"token operator\">=></span> g<span class=\"token punctuation\">.</span><span class=\"token function\">Count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">OrderByDescending</span><span class=\"token punctuation\">(</span>g <span class=\"token operator\">=></span> g<span class=\"token punctuation\">.</span>Key<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">Select</span><span class=\"token punctuation\">(</span>g <span class=\"token operator\">=></span> <span class=\"token keyword\">new</span> <span class=\"token punctuation\">{</span> g<span class=\"token punctuation\">.</span>Key<span class=\"token punctuation\">,</span> Count <span class=\"token operator\">=</span> g<span class=\"token punctuation\">.</span><span class=\"token function\">Count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","fields":{"slug":"/blog/2016/sql/"},"frontmatter":{"title":"The Structured (English) Query Language","date":"December 14, 2016","tags":["sql"],"description":null}},"previous":{"fields":{"slug":"/blog/2016/sitecore-in-docker/"},"frontmatter":{"title":"Running Sitecore in Docker"}},"next":{"fields":{"slug":"/blog/2017/danish-ml/"},"frontmatter":{"title":"Danish and naïve machine learning"}}},"pageContext":{"id":"0e4f4a7b-ed27-54ab-8a74-62bea4cae571","previousPostId":"f99f5a3b-5594-562f-86f4-5ccc5c6a722d","nextPostId":"c44a98ec-daf5-55d0-a679-3bfaf2b9207b"}},"staticQueryHashes":["2841359383"]}